#importing packages and classes
import unittest
import warnings
from pathlib import Path
import json
from headlines import HeadlineChecker

#calling the GUI output (which is the dictionary output of the gui.py code). 
with open("config.json", "r", encoding='utf-8') as config_file:
    gui_output = json.load(config_file)

class TestExcelInspector(unittest.TestCase):
    """
    Test case class for testing the HeadlineChecker class.
    This test is responsible for testing whether the warnings generated by the 
    HeadlineChecker class match the expected warnings defined in the test for a single case of previously provided files.
    """

    def setUp(self):
        """
        Setting up the environment for the test.
        This method initializes paths to the item and practice files, and retrieves 
        settings such as context inclusion and answer options from the config.json file.
        """
        self.test_file_path1 = Path('demo_items_messing_c_and_cells.csv') #defining the path of the first file.
        self.test_file_path2 = Path('warning_if_custom.csv') #defining the path of the second file.
         # Determining if context is included based on the config.json 
        if gui_output['sections']['context'] == 'yes': #if a cotext is included create a cotext variable. 
             self.context_answer = gui_output['sections']['context'] 
        else: 
             self.context_answer = 'no'
        self.answer_options=gui_output['sections']['answers'] #creating 'answer type 'variable as provided (yes/no or custom).

        
    def test_HeadlineChecker(self):
        """"
        Testing the HeadlineChecker for generating the correct warnings.
        This method instantiates the HeadlineChecker with the provided file paths and settings,
        runs the relevant methods to generate warnings, and checks if the generated warnings 
        match the expected warnings.
        """
    
        inspector = HeadlineChecker(demo_items=self.test_file_path1,demo_practice=self.test_file_path2,include_context=self.context_answer,answers=self.answer_options)  #instantiating the HeadlineChecker with the current settings.
        
        #expected warning messages
        expected_warnings = [
    "Warning: The following essential headlines are not found in the item file: ['context']",
    "Warning: Please update the headlines according to the following list: ['group', 'set', 'condition', 'sentence', 'question', 'context']",
    "Warning: The following essential headlines are not found in the item file: ['condition', 'context']",
    "Warning: Please update the headlines according to the following list: ['sentence', 'condition', 'question', 'context']",
    "Warning: The file 'demo_items_messing_c_and_cells.csv' does not match the expected name 'demo_items.csv'.",
    "Warning: The file 'warning_if_custom.csv' does not match the expected name 'demo_practice.csv'.",
    "Warning: 'FIRST_answer' is essential but not found in the item file.",
    "Warning: 'SECOND_answer' is essential but not found in the item file."
]

        with warnings.catch_warnings(record=True) as caught_warnings: #capturing warnings generated by the HeadlineChecker
        
            warnings.simplefilter("always")
            
            # generating the warnings
            inspector._check_item_practice_headlines()
            inspector.extract_filename()
            inspector.check_if_noun_requires_answers()

            # Checking if each generated warning is in the list of expected warnings
            actual_warnings = [str(w.message) for w in caught_warnings]
        for warning in actual_warnings:
            with self.subTest(warning=warning):
                self.assertIn(warning, expected_warnings, f"Unexpected warning: {warning}")

        print("All generated warnings were found in the expected warnings list.")

        print("The test will show 'OK' if it passes, don't freak out by the warnings generated!! these warnings are just the ones that should appear when using the methods of the HeadlineChecker that we are testing.")
        
if __name__ == '__main__':
    unittest.main()